

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>agh-mirosot-vision &mdash; agh-mirosot-vision v0.1 documentation</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="agh-mirosot-vision v0.1 documentation" href="#" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="#">
          <span>agh-mirosot-vision v0.1 documentation</span></a></h1>
        <h2 class="heading"><span>agh-mirosot-vision</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="#">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="agh-mirosot-vision">
<h1>agh-mirosot-vision<a class="headerlink" href="#agh-mirosot-vision" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="dokumentacja-interfejsu">
<h2>Dokumentacja interfejsu<a class="headerlink" href="#dokumentacja-interfejsu" title="Permalink to this headline">¶</a></h2>
<p>Ze względu na wymagania dotyczące wydajności i konieczność współpracy z
maksymalnie różnorodnymi środowiskami algorytm rozpoznawania robotów został
zaimplementowany jako program w języku C++ z interfejsem w C. Taka konfiguracja
zapewnia maksymalną kompatybilność z dowolnym językiem programowania.</p>
<p>Cała istota algorytmu jest zawarta w jednej funkcji:</p>
<dl class="function">
<dt id="find_teams">
robot_data <tt class="descname">find_teams</tt><big>(</big><a class="reference internal" href="#mirosot_vision_config" title="mirosot_vision_config">mirosot_vision_config</a>*<em> config</em><big>)</big><a class="headerlink" href="#find_teams" title="Permalink to this definition">¶</a></dt>
<dd><p>Przyjmuje ona dane wizualne i tworzy opis drużyn robotów.</p>
</dd></dl>

<dl class="type">
<dt id="mirosot_vision_config">
struct <tt class="descname">mirosot_vision_config</tt><a class="headerlink" href="#mirosot_vision_config" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">mirosot_vision_config</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">image</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">;</span>

    <span class="n">image_pos</span><span class="o">*</span> <span class="n">white_points</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">white_points_len</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">px_per_cm</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">robot_size</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">meanshift_radius</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">meanshift_threshold</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">debug_balance</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">debug_prescreen</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">debug_meanshift</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">debug_patches</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">debug_robots</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Strukturę należy zainicjalizować funkcją <tt class="docutils literal"><span class="pre">init_config</span></tt>, która wypełnia
pola wartościami domyślnymi i przygotowuje zawartość tablic pomocniczych
ukrytych w polu <tt class="docutils literal"><span class="pre">state</span></tt>.</p>
</dd></dl>

<p>Poniżej opisane są poszczególne elementy struktury.</p>
<div class="section" id="bitmapa">
<h3>bitmapa<a class="headerlink" href="#bitmapa" title="Permalink to this headline">¶</a></h3>
<p>Struktura wejściowa zawiera wskaźnik do obrazka, z którego ma zostać wyciągnięta
informacja o robotach. Dane koloru pikseli bitmapy są zapisane jako 3 bajty w
formacie BGR, czyli dla wskaźnika <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char*</span> <span class="pre">ptr</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">B</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>Wartości pikseli obrazka na współrzędnych x i y są określone wzorem
<tt class="docutils literal"><span class="pre">img(x,</span> <span class="pre">y)</span> <span class="pre">=</span> <span class="pre">img_ptr[3*(x</span> <span class="pre">+</span> <span class="pre">y*width)]</span></tt>, czyli piksele są upakowane ciasno
w przestrzeni adresowej i są przechowywane wierszami.</p>
<p>Alokacją obrazka zajmuje się użytkownik.
<strong>Zawartość bitmapy zostaje zamazana po wywołaniu find_teams</strong></p>
</div>
<div class="section" id="inicjalizacja">
<h3>inicjalizacja<a class="headerlink" href="#inicjalizacja" title="Permalink to this headline">¶</a></h3>
<p>Pola, które w normalnym działaniu algortymu zostają ustawiane tylko raz:</p>
<dl class="member">
<dt id="mirosot_vision_config.px_per_cm">
double <tt class="descname">mirosot_vision_config.px_per_cm</tt><a class="headerlink" href="#mirosot_vision_config.px_per_cm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="mirosot_vision_config.robot_size">
double <tt class="descname">mirosot_vision_config.robot_size</tt><a class="headerlink" href="#mirosot_vision_config.robot_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Podają odpowiednio rozdzielczość obrazu na powierzchni boiska (w pikselach
na centymetr) i długość boku robota w centymetrach.</p>
</dd></dl>

<dl class="member">
<dt id="mirosot_vision_config.white_points">
image_pos *<tt class="descname">mirosot_vision_config.white_points</tt><a class="headerlink" href="#mirosot_vision_config.white_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Pozycje punktów boiska, które można określić jako białe.</p>
</dd></dl>

<dl class="member">
<dt id="mirosot_vision_config.meanshift_radius">
int <tt class="descname">mirosot_vision_config.meanshift_radius</tt><a class="headerlink" href="#mirosot_vision_config.meanshift_radius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="mirosot_vision_config.meanshift_threshold">
int <tt class="descname">mirosot_vision_config.meanshift_threshold</tt><a class="headerlink" href="#mirosot_vision_config.meanshift_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Rozmiar okna algorytmu meanshift i odległość obcięcia koloru. Rozmiar okna
może mieć duży wpływ na wydajność.</p>
</dd></dl>

<dl class="member">
<dt id="debug_balance.debug_balance">
unsigned char *<tt class="descname">debug_balance.debug_balance</tt><a class="headerlink" href="#debug_balance.debug_balance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="debug_balance.debug_prescreen">
unsigned char *<tt class="descname">debug_balance.debug_prescreen</tt><a class="headerlink" href="#debug_balance.debug_prescreen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="debug_balance.debug_meanshift">
unsigned char *<tt class="descname">debug_balance.debug_meanshift</tt><a class="headerlink" href="#debug_balance.debug_meanshift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="debug_balance.debug_patches">
unsigned char *<tt class="descname">debug_balance.debug_patches</tt><a class="headerlink" href="#debug_balance.debug_patches" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="debug_balance.debug_robots">
unsigned char *<tt class="descname">debug_balance.debug_robots</tt><a class="headerlink" href="#debug_balance.debug_robots" title="Permalink to this definition">¶</a></dt>
<dd><p>Jeśli któreś z tych pól zostanie ustawione na bufor zaalokowany przez
użytkownika, zostanie on wypełniony kopią obrazka z pola image z
domalowanymi elementami mogącymi wspomóc diagnozowanie problemów z
algorytmem.</p>
</dd></dl>

</div>
</div>
<div class="section" id="opis-algorytmu">
<h2>Opis algorytmu<a class="headerlink" href="#opis-algorytmu" title="Permalink to this headline">¶</a></h2>
<div class="section" id="linearyzacja">
<h3>1. Linearyzacja<a class="headerlink" href="#linearyzacja" title="Permalink to this headline">¶</a></h3>
<p>Najbardziej popularny sposób kodowania kolorów w kamerach i innych urządzeniach
przetwarzania obrazu to nieliniowo kodowana przestrzeń sRGB. Aby powiązać
wartość liczbową piksela z fizyczną energią światła, wartość piksela należy
zlinearyzować.</p>
</div>
<div class="section" id="regulacja-balansu-bieli">
<h3>2. Regulacja balansu bieli.<a class="headerlink" href="#regulacja-balansu-bieli" title="Permalink to this headline">¶</a></h3>
<p>Wiedząc, że pomalowany na biało przedmiot posiada kolor <img class="math" src="_images/math/bb69dbc08b11102cd2686307e3db37a21220c988.png" alt="(w_r, w_g, w_b)"/>,
bardzo łatwo przekolorować bitmapę, by biały wyglądał na biały. Wystarczy
dla każdego piksela <img class="math" src="_images/math/36f73fc1312ee0349b3f3a0f3bd9eb5504339011.png" alt="p"/> zastosować prostą transformację:</p>
<div class="math">
<p><img src="_images/math/55255f137b60a14406d08d2c1f163315cbded6cc.png" alt="(p'_r, p'_g, p'_b) = (p_r\cdot\frac{255}{w_r}, p_g\cdot\frac{255}{w_g}, p_b\cdot\frac{255}{w_b})" /></p>
</div><p>Jeśli <img class="math" src="_images/math/9ee4b825a2e36ae093ed7be5e4851ef453b34914.png" alt="w"/>, czyli punkt bieli jest znany i taki sam, na tym można zakończyć
balans. Co jednak, jeśli punkt bieli jest różny w różnych punktach obrazu?
Wtedy w każdym punkcie obrazu (tak naprawdę na każdym małym kafelku obrazu)
wyznaczamy punkt bieli jako średnią ważoną wagą <img class="math" src="_images/math/c95e21179500b878311d0f020631d511dac0ddac.png" alt="\frac{1}{r^2}"/>,
gdzie <img class="math" src="_images/math/b55ca7a0aa88ab7d58f4fc035317fdac39b17861.png" alt="r"/> to odległość punktu z bielą do badanego punktu.</p>
</div>
</div>
<div class="section" id="transformacja-do-hsv">
<h2>3. Transformacja do HSV<a class="headerlink" href="#transformacja-do-hsv" title="Permalink to this headline">¶</a></h2>
<p>Obok obrazka w formacie RGB tworzony jest jego odpowiednik HSV.</p>
</div>
<div class="section" id="wstepne-zaznaczanie-kandydatow">
<h2>4. Wstępne zaznaczanie kandydatów<a class="headerlink" href="#wstepne-zaznaczanie-kandydatow" title="Permalink to this headline">¶</a></h2>
<p>Piksele, które wpadają w odpowiedni przedział barwy (H) i nasycenia (S) są
oznaczane jako kandydaci do dalszego przetwarzania w zbiorach pikseli żółtych i
niebieskich.</p>
</div>
<div class="section" id="meanshift">
<h2>5. Meanshift<a class="headerlink" href="#meanshift" title="Permalink to this headline">¶</a></h2>
<p>Algorytm segmentacji meanshift posiada wstępną fazę filtrowania, która wygładza
jednolite obszary, tak że po filtrowaniu stanowią jeden jednolity kolor.
Istotę tego filtrowania można stosować do każdego piksela z osobna. Dzięki temu,
że po filtrowaniu jednokolorowe obszary są bardzo jednolite, można je wyodrębnić
za pomocą zwykłego algorytmu flood-fill.</p>
</div>
<div class="section" id="obszary">
<h2>6. Obszary<a class="headerlink" href="#obszary" title="Permalink to this headline">¶</a></h2>
<p>Następnie obszary są segregowane na podstawie ich rozmiaru. Za duże lub za małe
obszary są odrzucane.</p>
</div>
<div class="section" id="regresja">
<h2>7. Regresja<a class="headerlink" href="#regresja" title="Permalink to this headline">¶</a></h2>
<p>Na wyodrębnionych obszarach wyznaczana jest linia minimalizująca
sumę kwadratów odległości pikseli od linii (regresja Deminga). Za jej pomocą
wyznaczamy kąt obrotu robota.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="#">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2011, Adam Chrabąszcz, Konrad Kras.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.1.
    </div>
  </body>
</html>